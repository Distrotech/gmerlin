<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [de] (X11; U; Linux 2.4.18 i686) [Netscape]">
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">
&nbsp;
<h2>
2. Converting video frames</h2>

<h3>
2.1 Format description</h3>
The input and output formats are
<br>defined in gavl_video_format_t structures:
<p><tt>typedef struct</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp; int width;</tt>
<br><tt>&nbsp; int height;</tt>
<br><tt>&nbsp; gavl_colorspace_t colorspace;</tt>
<br><tt>&nbsp; } gavl_video_format_t;</tt>
<p>Width and height are the size of the picture. colorspace is an enum:
<p><tt>typedef enum</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_COLORSPACE_NONE = 0,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_RGB_15,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_BGR_15,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_RGB_16,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_BGR_16,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_RGB_24,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_BGR_24,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_RGB_32,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_BGR_32,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_RGBA_32,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_YUY2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_YUV_420_P,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; GAVL_YUV_422_P</tt>
<br><tt>&nbsp; } gavl_colorspace_t;</tt>
<p>Some confusion exists about the definition of RGB and BGR order. No
matter if this is a "standard" or whatever, here comes the definition of
gavl:
<p>RGB byte order for 24 and 32 bpp means, that if you have a scanline
pointer
<p><tt>uint8_t * pixels;</tt>
<p>the red byte is the FIRST element, i.e pixels[0]. BGR means, that the
blue byte is the first element. RGB order for 15 and 16 bpp formats means,
that the red bits are the HIGHEST bits of a 16 bit short, which represents
a pixel.BGR order, the HIGHEST bits are blue. The YUV formats are pretty
well standardized, so gavl should be compatible with most software here.
Note, that gavl makes no difference between the various planar YUV420 formats.
The Chroma pointers of the video frames are always set explitcitly, so
their order in the isn't important here.
<p>Some utility functions exist for colorspaces:
<p><tt>int gavl_colorspace_is_rgb(gavl_colorspace_t colorspace);</tt>
<p><tt>int gavl_colorspace_is_yuv(gavl_colorspace_t colorspace);</tt>
<p><tt>int gavl_colorspace_has_alpha(gavl_colorspace_t colorspace);</tt>
<p>returns TRUE is the colorspace is rgb, yuv or has transparency information.
These can be used to determine the best colorspace, your applitation should
use. Colorspaces can be converted to human readable strings (mostly for
debugging) with:
<p><tt>const char * gavl_colorspace_to_string(gavl_colorspace_t colorspace);</tt>
<p>The reverse function of this is:
<p><tt>gavl_colorspace_t gavl_string_to_colorspace(const char *);</tt>
<p>You can make your application somewhat independent from the supported
colorspaces, if you program some loops, which process all supported colorspaces.
For this you can get the total number of supported colorspaces with:
<p><tt>int gavl_num_colorspaces();</tt>
<p>Inside the loop, get the i'th colorspace with
<p><tt>gavl_colorspace_t gavl_get_colorspace(int index);</tt>
<h3>
2.2 Creating and destroying video frames</h3>
Video frames in gavl are stored in structures gavl_video_frame_t:
<p><tt>typedef struct gavl_video_frame_s</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp; /* For planar formsts */</tt>
<p><tt>&nbsp; uint8_t * y;</tt>
<br><tt>&nbsp; uint8_t * u;</tt>
<br><tt>&nbsp; uint8_t * v;</tt>
<p><tt>&nbsp; int y_stride;</tt>
<br><tt>&nbsp; int u_stride;</tt>
<br><tt>&nbsp; int v_stride;</tt>
<p><tt>&nbsp; /* For packed formats */</tt>
<p><tt>&nbsp; uint8_t * pixels;</tt>
<br><tt>&nbsp; int pixels_stride;</tt>
<p><tt>&nbsp; int bytes_per_line; /* Bytes per line, used internally only
*/</tt>
<p><tt>&nbsp; } gavl_video_frame_t;</tt>
<p>The pixels member points to the pixel data for all packed formats. It
points to the first (normally top-) scanline of the frame. The next scanline
starts at an offset of pixels_stride (always in bytes). For planar YUV
formats, you have the y, u (or Cb) and v (or Cr) pointers and their stride
offsets.
<br>For displaying video frames in a window application, you should allocate
XImages (or XVImages or whatever) and set the pointers in the frame structure
manually. If your application allows to allocate video frames using the
usual malloc routines, you should better use:
<p><tt>gavl_video_frame_t * gavl_create_video_frame(gavl_video_format_t*);</tt>
<p>to create a frame and
<p><tt>void gavl_destroy_video_frame(gavl_video_frame_t*);</tt>
<p>to destroy it again. The memory will be aligned at proper byte boundaries,
so that MMX processing becomes faster. There are some other utility routines:
<p><tt>void gavl_clear_video_frame(gavl_video_frame_t * frame, gavl_video_format_t
* format);</tt>
<p>Makes a frame black.
<h3>
2.3 Converting video frames</h3>
The generic structure for converting video frames is gavl_video_converter_t.
It's an anonymous pointer, which can only be created and destroyed by gavl
functions. To create a video converter, use:
<p><tt>gavl_video_converter_t * gavl_create_video_converter();</tt>
<p>You will also want to set some conversion options. All options are in
a structure gavl_video_options_t:
<p><tt>typedef struct</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp; int accel_flags; /* CPU Acceleration flags */</tt>
<br><tt>&nbsp; int conversion_flags;</tt>
<p><tt>&nbsp; float crop_factor; /* Not used yet (for scaling) */</tt>
<p><tt>&nbsp; /* Background color (0x0000 - 0xFFFF) */</tt>
<p><tt>&nbsp; uint16_t background_red;</tt>
<br><tt>&nbsp; uint16_t background_green;</tt>
<br><tt>&nbsp; uint16_t background_blue;</tt>
<p><tt>&nbsp; } gavl_video_options_t;</tt>
<p>accel_flags is an ORed combination of the optimization flags.
<p>Conversion flags are additional flags for modifying the bevahiour of
the converter. Currently, only GAVL_SCANLINE is supported to switch to
optimized scanline functions, which take only one scanline at a time and
don't care about the picture height.
<br>'The background color will be blended in, when an alpha capable colorspace
(like RGBA32) is converted to a colorspace without alpha.
<p>You are now free to use it for different type of conversions. If your
player loads a movie, and it found out the best input and output formats,
you initialize the gavl converter if the input and output formats are different.
Do this by calling:
<p><tt>int gavl_video_init(gavl_video_converter_t* cnv,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const gavl_video_options_t * options,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const gavl_video_format_t * input_format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const gavl_video_format_t * output_format);</tt>
<p>cnv is the converter you allocated with gavl_create_video_converter().
The options pointer are the options described above.
<br>gavl_video_init() will seek for the conversion functions and set up
all tables (if needed). If the conversion is impossible (e.g. if you selected
flags, for which the necessary routines are missing), the function returns
FALSE. Therefore, you should always select CAVL_ACCEL_C.
<p>One you called gavl_video_init(), you can convert an arbitrary number
of video frames by successive calls to:
<p><tt>void gavl_video_convert(gavl_video_converter_t * cnv,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gavl_video_frame_t * input_frame,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
gavl_video_frame_t * output_frame);</tt>
<p>If the movie is over, you can reuse the video converter by simply calling
gavl_video_init() with the new format. When you are done at all, use
<p>gavl_destroy_video_converter(gavl_video_converter_t *);
<p>to release all resources associated with the video converter.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
